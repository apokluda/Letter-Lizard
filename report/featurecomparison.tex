\section{Scripting Language Feature Comparison}
\label{comparison}

% Compare language features. Show examples for one or more language implementations
% whenever possible. The structure of this section will be a feature-by-feature comparison
% first, backed up by examples (or hypothetical examples) where possible.

% comparing the most major differences that we noticed using examples from our three implementations (when possible)
% don't have space to go into all the details
% First difference noted already: environments/frameworks led to different design

% NOT COVERED:
% Many differences: Types, Variables, Values (including Numeric and Boolean types, Strings)
% Special Types such as (nil, null and undefined)

% COVERED:
% Data Structures: arrays, lists, tuples, dictionaries (Python); Objects (JavaScript); Tables (Lua)

% NOT COVERED:
% Expressions and Statements, Flow Control

% COVERED: Variable Scope

% COVERED: Functions, closures, coroutines, generators, iterators

% NOT COVERED: Exception Handling, Modules and Packages

\lettrine[nindent=0em,lines=3]{N}{ow} that we have introduced the three implementations of
our Letter Lizard game, we will will compare and contrast the differences between
each language, noting their strengths and weaknesses, using example code from our
implementations where possible. When coding the Letter Lizard game in each language,
we tried to follow the same structure as much as possible, however, as was noted in section~\ref{lljs}
the event-driven environment of client-side JavaScript naturally led to a different
design for that implementation. Due to space constraints, we will skip over some of
the differences that we noticed between the types, variables and values (including 
the numeric, boolean and string types and the null, undefined and nil special values)
offered by each language.
We will, however, discuss the differences between the data structures offered by
Python (i.e. lists, tuples and dictionaries), JavaScript (i.e. objects and arrays)
and Lua (i.e. tables and arrays). We noted differences between the syntax and semantics
of expressions and statements in each language, as well as the flow
control constructs offered, which we will omit; however, we will discuss
variable scope, functions, and closures. The first major difference that we
noticed between the languages was non-function: each employed a different lexical
structure, which we discuss next.

\subsection{Lexical Structure}
% LEXICAL STRUCTURE
% STATEMENTS
% - Python: intentation sensitive; JavaScript: automatic semicolon insertion; 
%   Lua neither
% LUA: CHUNKS
% - Chunks: Lua specific thing
% COMMENTS
Since we implemented the game in three different languages we were able to examine the difference in lexical structure quite minutely. With regard to programming languages, the syntax of the language defines the set of symbols that are considered to be a correctly structured document in that particular language. Python is inherently designed to be a highly readable language and uses words of the English language instead of punctuation marks. As compared to other languages, Python uses white space indention rather than curly braces or keywords to delimit blocks. This is a strength of the language as good indention is enforced by the language itself and makes for highly readable, clean code. However, on the downside tabs and spaces can be easily mixed up leading bugs in the code. 

JavaScript uses blocks delimited by curly braces which means that code can be 'minimized' for the Web. However, automatic semicolon insertion  can lead to errors and is generally not considered very good by JavaScript programmers. This is one of the controversial syntactic features of JavaScript. For instance, consider the following code snippet:
\begin{lstlisting}[language={JavaScript}, %
  title={}, label=semicolon]
	a = b + c
   (d + e).print()
\end{lstlisting}

In this, the code is not transformed by automatic semicolon insertion, because the parenthesized expression that begins the second line can be interpreted as an argument list for a function call:

\begin{lstlisting}[language={JavaScript}, %
  title={}, label=semicolon]
	a = b + c(d + e).print()
\end{lstlisting}

In Lua the statements and blocks are delimited by newlines and keywords to begin and end constructs help in minimizing errors. But it can lead to extremely messy code unless indention conventions are strictly followed

% AUTHOR: AFIYA

\subsubsection{Data Structures}
% - Arrays, Lists, Tuples, Dictionaries
%   - only Python has all of these, Lua and JavaScript have tables/objects with 
%     special properties (covered under Objects)
%   - list comprehensions

% AUTHOR (INTRO): AFIYA
Data structure is a particular way of storing and organizing data in a computer so that it can be used efficiently. There are different kinds of data structures available which are suited for performing different tasks. In our implementations of Letter Lizard, we extensively used the different data structures provided by each language for holding, structuring and manipulating our data efficiently. Almost all three of our implementations had data structures for holding the scrambled puzzle letters, letters guessed correctly, letters to be displayed on the screen and so on. We will now describe the data structures in all our three implementations.
\paragraph{Python: Arrays, Lists, Tuples and Dictionaries}

% AUTHOR: MIKE

\paragraph{JavaScript: Objects}

% Fundamental datatype: Object
% - composite value, aggregates multiple values (primitive values (i.e. string, number, bool, 
%   null, undefined) or other objects); unordered collection of properties
% - even though strings, numbers, booleans are not objects, the behave like objects
% - allows you to store and retrieve those objects by name
% - maps strings to values: dictionary in Python (but used differently; not central to the lang)
%   or tables in Lua (very similar usage, but more powerful)
% - also inherits properties from prototype object
% - "prototypal inheritance" is a key feature of JavaScript
% - dynamic (props added / deleted at runtime) but can be used to simulate static (class-based)
%   objects and structs
% - GIVE CODE EXAMPLE
% - can be used to represent sets of strings; other objects, not so easily

JavaScript has one fundamental datatype: Object. Everything that is not either a
primitive type, null or undefined is an object. (The primitive types in JavaScript are
number, string and boolean. Although they are not objects, they behave like immutable
objects). Objects are composite values that aggregate multiple values, which may be
primitive types or other objects, and allow you to store and retrieve those values
by name. Objects are similar to Python's dictionary and Lua's table data structure, but
unlike Python's dictionary, Objects are a core feature of JavaScript. All variables are
contained within objects and, as we will see later in section~\ref{functions}, even
the scope of a variable is implemented in terms of a chain (or linked list) of objects.
Lua's tables are very similar to JavaScript objects and play a similar role in the
implementation of the language, but they are even more powerful.

JavaScript objects are dynamic--rather than having a static type, properties can be added
and removed at run-time and support ``duck typing.'' LetterLizardJS makes use of many
user-defined objects. The following code defines an object \texttt{letterpoints} that
maps letters (property names) to the number of points that the letter is worth
(property values) when included in a word found by the player:

\begin{lstlisting}[caption=A user-defined object in JavaScript.]
var letterpoints = {
	'A': 3,
	'B': 8,
	'C': 6,
	...
	'Z': 10
};
\end{lstlisting}

Another example of a user-defined object in LetterLizardJS is shown below. This code
snippet is from the Game constructor function. It adds a property called 
\texttt{words} to the Game object being constructed and assigns an empty object
to it on line 2. Then it iterates through a randomly chosen ``game'' (i.e. a
randomly chosen set of letters and corresponding words to be found) and creates
a Word object to represent each word to be found. Word objects draw themselves to the
screen either as text or a placeholder when the word is yet to be found. The Word
objects are assigned to the words object by dynamically creating properties mapping
the text of each word to its corresponding Word object.

\begin{lstlisting}[caption=A user-defined object demonstrating dynamic properties.]
	var game = games[config.difficulty][i];
	this.words = {};
	for (var i = 0; i < game.words.length; ++i) {
		var word = game.words[i];
		this.words[word] = new Word(word);
	}
\end{lstlisting}

\paragraph{Lua: Tables}

% AUTHOR: AFIYA
Lua offers a single, fundamental data structure: \texttt{Tables}. Tables are the only data structure in Lua. All the other structures that the language offers can be represented as Tables efficiently. In traditional languages like C and C++, most of the structures are represented with arrays and lists. However, in Lua, tables are more powerful than either. The algorithms used for implementing these structures in traditional languages are simplified with the use of tables. Tables offer direct access to any type. Tables are fundamentally associative arrays, i.e., they are key-value pairs in which the keys can be any legitimate value in Lua. Tables are quite similar to the 'Object' type of JavaScript, the difference being that in JavaScript objects, the keys can be only either strings or integers, whereas in Lua tables, the keys can be any legitimate value in Lua except nil. We now describe the different structures in Lua that we defined using tables.
Tables are very easy to create. An empty table can be assigned to any variable by specifying empty curly braces which denotes an empty table constructor. For instance, throughout our code, we have declared tables easily and efficiently as shown in the following code.

\begin{lstlisting}[language={[5.2]Lua},caption= Declaring tables in Letter lizard]
	  games_letters = {}
	  letters_guessed = {}
	  solutions = {}
	  words_guessed_correct = {}
\end{lstlisting}

Arrays in Lua can be implemented efficiently using Lua tables by simply indexing the tables with integers. Hence, arrays do not have a finite size, instead they can grow in size as needed. The following code snippet is an example of an array implementation from Lua Letter Lizard. By convention, array indexing starts from 1 in Lua.

\begin{lstlisting}[language={[5.2]Lua},caption= An array structure which holds pre-generated game puzzles easily accessed by indexing the table]
	 games_words = {}
     games_words = games.easy[1].words
\end{lstlisting}

Metatables are a very powerful structure offered by Lua. Metatables allow us to change the behavior of a table. For instance, using metatables we can define how Lua computes the expression \texttt{a+b} where \texttt{a} and \texttt{b} are tables. In our code we have used metatables to declare action to be taken when we are in a particular state. In the following code, we declare two tables \texttt{menu} and \texttt{game} corresponding to the states 'menu' and 'game'. We define callback functions within these state tables which override the default callbacks provided by Love and are called when the game is in a particular state. Functions are declared within the two tables as easily as \texttt{function menu:init()} or \texttt{function game:keypressed()}.

\begin{lstlisting}[language={[5.2]Lua},caption= Declaring and initializing metatables in Lua]
local menu = {}
function menu:init()

    splash = love.graphics.newImage("splash.png")
end

function menu:draw()
    love.graphics.setColor(255,255,255,255)
    love.graphics.draw(splash, 0 ,0)
end

function menu:keypressed(key)
    if key == ' ' then
        Gamestate.switch(game)
    end
end
\end{lstlisting}



\subsection{Variable Scope}
\label{varscope}
% VARIABLE SCOPE
% - local variables vs global variables
% - block scope vs function scope
% - Lua do blocks

% AUTHOR: ALEX

% Scope: visibility of a name within a block

% Python: 
% - if variable is defined in a block, its scope includes that block
% - if variable is defined in function block, scope extens to any blocks
%   contained within the defining one, unless a contained block introduces a different
%   binding for the name
% - when a name is used in a code block, it is resolved using the nearest enclosing
%   scope
% - if a name binding occurs anywhere in a block, all uses of the name withith the
%   block are treated as references to the current block (same thing as JavaScript)
% - only means to create scope for variables is functions, classes and modules

Overall, we discovered that Lua and JavaScript have many more similarities with
each other than they do with Python; however, variable scope is one area
where this differs. Both Python and JavaScript implement function scoping. The only
means to create a scope for a variable in Python is a function, class or module and
just a function in JavaScript. The official Python documentation states: 
``If a name binding operation occurs anywhere within a code block, all uses of the 
name within the block are treated as references to the current block~\cite{pyscope}.'' 
This subtle point can lead to surprising results, especially for programmers not
intimately familiar with the scoping rules in these languages. Consider the
following example:

\begin{lstlisting}[language=Python,caption=A demonstration of function scope in Python.]
a = 42
def f():
	print(a)
	if (True):
		a = 43
f()
\end{lstlisting}

Most programmers familiar with the block scoping rules of C, C++, and Java would expect
this code to print 42; however, it results in an \texttt{UnboundLocalError} because
the assignment on line 5 creates a new local variable called ``a'' that shadows the
variable with the same name at the global scope and is visible throughout the
entire function, but when line 3 is executed, this variable has not yet been assigned
a value. Also, because Python lacks an explicit variable declaration statement,
it is not clear whether the assignment on line 5 was intended to create a new
local variable or change the value of the global variable. In fact, prior to Python 3,
there is no way for code in an inner scope to assign a value to an enclosing scope
that is not the global scope. (Python 3 fixes this with the introduction of the 
\texttt{nonlocal} statement).

JavaScript uses function scoping for variables, similar to Python, which means that all 
variable declared in a function are visible throughout the entire body of the function.
Unlike Python, though, JavaScript has an explicit variable declaration statement and
this feature is known as ``hoisting:'' JavaScript code behaves as if all 
variable declarations in a function are hoisted to the top of the function. In both
languages, this feature can easily cause bugs that are hard to find when local variables
shadow variables in an outer scope, and for this reason it is considered a negative 
feature~\cite{goodparts}.

% Lua:
% - block: body of control structure, body of a function, or chuck (code treated as a 
%   unit), or explicit block with do ... end
% - local-variable declarations as statements
% - can write local declaration anywhere that you can write a statement
% - scope of declared variable begins after declaration and goes until the end of the 
%   block

On the other hand, Lua implements block scope similar to C, C++ and Java.
The body of a control structure, body of a function, or chunk (a segment of
code that is treated as a unit) all introduce new scopes. Additionally,
new scopes can be created explicitly with the keywords \textbf{do} ... \textbf{end}.
The scope of a declared variable begins after the declaration and goes until the
end of the block. When written in Lua, as shown below, the previous example
will print 42. 

\begin{lstlisting}[language={[5.2]Lua},caption=A demonstration of block scope in Lua.]
a = 42
function f()
	print(a)
    if (true) then
        local a = 43
    end
end
f()
\end{lstlisting}

\subsection{Functions}
\label{functions}
% FUNCTIONS
% - how are arguments passed? (Python: must number of arguments match? Doesn't have to 
% in JavaScript and Lua)
% - Python's name-based arguments vs passing objects in JavaScript / Lua
% - scope
% - return value
% - functions as values

% Be Very Brief!

% AUTHOR (INTRO): ALEX

\subsubsection{Closures}
\label{closures}
% - closures, coroutines

% AUTHOR (PARAGRAPH ON JAVASCRIPT): ALEX
% AUTHOR (PARAGRAPH ON LUA): AFIYA
\paragraph{Lua: Closures}
Closures are a powerful tool offered by any programming language. Closures are basically functions written within functions such that they have access to the local variables from the enclosing function. Lua also supports closures. These act as a valuable tool in many contexts. In our implementation, closures were very useful for implementing callback functions in creating the GUI buttons. Each button has a callback function to be called when we create the button. For instance in the following code snippet, we utilize an external GUI library for Love called \texttt{LoveFrames} to create the 'New Game' button. LoveFrames uses closure function to 'create' the button, set its positions and define the button name.
\begin{lstlisting}[language={[5.2]Lua},caption= Declaring and initializing metatables in Lua]
newgame_button = loveframes.Create("button")
    newgame_button:SetSize(button_width, button_height)
    newgame_button:SetPos(100, 400)
    newgame_button:SetText("NEW GAME")
\end{lstlisting}
    

\subsubsection{Generators and Iterators}
% GENERATORS, ITERATORS

% AUTHOR: MIKE (OR REMOVE THIS SECTION)

\subsection{Object-Oriented Programming}
\label{oop}
% OBJECT ORIENTED PROGRAMMING
% - class-based inheritance vs prototype based inheritance
% - private data
% - JavaScript: no distinction between func and method: caling convention (same with Lua)

% AUTHOR (PARAGRAPH ON JAVASCRIPT): ALEX

In addition to having their own set of properties (known as ``own properties'') every
object is associated with and inherits properties from another object called its
\emph{prototype} object. This 'prototypal inheritance' is a key feature of JavaScript.
Prototypal inheritance was chosen for JavaScript because it fits nicely with JavaScript's
dynamic nature. Nevertheless, static class-based
objects, structs and inheritance hierarchies can be simulated in JavaScript. 

LetterLizardJS makes extensive use of objects and protoypes. The 

% AUTHOR (PARAGRAPH ON PYTHON): MIKE
% AUTHOR (PARAGRAPH ON LUA): AFIYA
\paragraph{Lua}
Lua does not support built in object oriented features but these can be simulated using Lua tables. Similar to objects, table have a state and identity independent of their values. Two tables with the same value are two different objects. We can store different values within a table field and access it using the dot operator. Lua tables also have support for the \texttt{self} parameter which tells the method on which object it has to operate on. With the use of the self parameter, the same method can be used to act on many objects. Lua adds a hidden self parameter with the colon operator. There is no notion of a 'class' but prototype based inheritance can be implemented using metatables which are similar to JavaScript objects but are more powerful. 
